<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Grails3文件上传到腾讯COS(OSS)]]></title>
    <url>%2F2018%2F11%2F30%2FGrails3%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%85%BE%E8%AE%AFcos_oss%2F</url>
    <content type="text"><![CDATA[在build.gradle中引入依赖1234// 腾讯云osscompile ('com.qcloud:cos_api:5.4.9') &#123; exclude group: 'org.slf4j', module: 'slf4j-log4j12'&#125; 在grails-app/conf下创建一个application-oss.yml文件123456oss: secretId: AKI**************************H7Ti secretKey: FN**************************Ns regionName: ap-chengdu bucket: img-555231231 accessAddr: http://www.baidu.com # 访问地址 然后在application.yml中加入123spring: profiles: include: oss 新建一个TencentConfig的JavaBean类 可以直接在grails-app/utils下，也可以在src/main/java下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package first.blood.cn.tools.oss.tencent;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;/** * 腾讯云oss初始化配置 * @Author Lee * @Description * @Date 2018年11月18日 18:51 */@Configuration@ConfigurationProperties(prefix = "oss")public class TencentConfig &#123; private String secretId; private String secretKey; private String regionName; private String bucket; //访问时的域名 private String accessAddr; public String getAccessAddr() &#123; return accessAddr; &#125; public void setAccessAddr(String accessAddr) &#123; this.accessAddr = accessAddr; &#125; public String getSecretId() &#123; return secretId; &#125; public void setSecretId(String secretId) &#123; this.secretId = secretId; &#125; public String getSecretKey() &#123; return secretKey; &#125; public void setSecretKey(String secretKey) &#123; this.secretKey = secretKey; &#125; public String getRegionName() &#123; return regionName; &#125; public void setRegionName(String regionName) &#123; this.regionName = regionName; &#125; public String getBucket() &#123; return bucket; &#125; public void setBucket(String bucket) &#123; this.bucket = bucket; &#125;&#125; 接下来创建一个文件上传的配置类（工具类）TencentOss 与前面的TencentConfig放在一个包下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package first.blood.cn.tools.oss.tencent;import com.qcloud.cos.COSClient;import com.qcloud.cos.ClientConfig;import com.qcloud.cos.auth.BasicCOSCredentials;import com.qcloud.cos.auth.COSCredentials;import com.qcloud.cos.model.ObjectMetadata;import com.qcloud.cos.model.PutObjectResult;import com.qcloud.cos.region.Region;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.io.IOException;import java.io.InputStream;/** * @Author Lee * @Description * @Date 2018年11月18日 18:35 */@Componentpublic class TencentOss &#123; @Autowired private TencentConfig tc; /** * 上传至腾讯云COS * * @param inputStream 输入流 * @param fileName 保存路径+文件名：/2018/11/21/demo.png * @param contentType 文件类型，默认是 application/octet-stream * @return */ public String upload(InputStream inputStream, String fileName) throws IOException &#123; COSClient cosClient = null; try &#123; // 1 初始化用户身份信息(secretId, secretKey) COSCredentials cred = new BasicCOSCredentials(tc.getSecretId(), tc.getSecretKey()); // 2 设置bucket的区域, COS地域的简称请参照 https://cloud.tencent.com/document/product/436/6224 // clientConfig中包含了设置region, https(默认http), 超时, 代理等set方法, 使用可参见源码或者接口文档FAQ中说明 ClientConfig clientConfig = new ClientConfig(new Region(tc.getRegionName())); // 配置使用https // 3 生成cos客户端 cosClient = new COSClient(cred, clientConfig); // bucket的命名规则为&#123;name&#125;-&#123;appid&#125; ，此处填写的存储桶名称必须为此格式 String bucketName = tc.getBucket(); ObjectMetadata objectMetadata = new ObjectMetadata(); PutObjectResult putObjectResult = cosClient.putObject(bucketName, fileName, inputStream, objectMetadata); String etag = putObjectResult.getETag(); &#125; finally &#123; if (inputStream != null) &#123; inputStream.close(); &#125; if (cosClient != null) &#123; cosClient.shutdown(); &#125; &#125; return tc.getAccessAddr() + "/" + fileName; &#125;&#125; 然后在程序入口类上加上@ComponetScan注解123456789101112package first.bloodimport grails.boot.GrailsAppimport grails.boot.config.GrailsAutoConfigurationimport org.springframework.context.annotation.ComponentScan@ComponentScanclass Application extends GrailsAutoConfiguration &#123; static void main(String[] args) &#123; GrailsApp.run(Application, args) &#125;&#125; 控制器方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 单文件上传 * @return */def imgFile() &#123; def map = [success: 0, message: "上传失败"] def file = null def inputStream = null try &#123; file = params["editormd-image-file"] inputStream = file.getInputStream() String fileName = file.getOriginalFilename() if (!file &amp;&amp; !fileName) &#123; map.message = "请选择图片文件" render map as JSON return &#125; // 判断文件大小，MAX_POST_SIZE自己定义 if (file.getSize() &gt; MAX_POST_SIZE) &#123; map.message = "只能上传不超过2M的图片文件" render map as JSON return &#125; // 判断是否是图片文件 if (!ImgUtils.isImage(file.getInputStream())) &#123; map.message = "只允许上传图片文件" render map as JSON return &#125; String prefix = fileName.substring(fileName.lastIndexOf(".")) // 新文件名，这里调用Date工具类生成目录结构2018/12/30 String newFileName = DateUtils.getUrl() + "/" + UUIDUtils.id() + prefix String accessAddr = oss.upload(inputStream,newFileName) map.success = 1 map.message = "上传成功" map.url = accessAddr &#125; catch (e) &#123; log.error("文件上传失败，msg=&#123;&#125;", e) map.message = "请检查参数是否正确，只能上传不超过2M的图片文件" &#125; render map as JSON&#125; 踩坑注意事项 文件流只能用一次 前面定义了inputStream在中途用过一次就会出问题，上传的文件只有几B大小，有的是0B]]></content>
      <categories>
        <category>Grails</category>
      </categories>
      <tags>
        <tag>Grails</tag>
        <tag>文件上传</tag>
        <tag>COS</tag>
        <tag>OSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Grails中如何绑定参数]]></title>
    <url>%2F2018%2F11%2F20%2FGrails%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425//参数绑定方式def bind = &#123; //方式一 //所有属性赋值 def user = new UserInfo(params).save() //方式二 //给所有属性赋值 def user1 = UserInfo.get(params.id) user1.properties = params user1.save() //方式三 //绑定指定对象，如/user/bind?user.username=张三&amp;user.age=20&amp;user.password=123456 def user3 = new UserInfo(params['user']) user3.save() //方式四 //给指定属性赋值 def user4 = UserInfo.get(params.id) user4.properties['firstName','lastName'] = params user4.save() //方式五，使用bindData方法 def user5 = new UserInfo() bindData(user5, params) //给所有属性赋值 bindData(user5, params, [exclude: ['username', 'password']]) //给exclude之外的属性赋值 bindData(user5, params, [include: ["dataCreated", "sex"]]) //只给include中的属性赋值&#125;]]></content>
      <categories>
        <category>Grails</category>
      </categories>
      <tags>
        <tag>Grails</tag>
        <tag>Groovy</tag>
        <tag>databind</tag>
        <tag>bind</tag>
        <tag>数据绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Grails3在utils中注入bean]]></title>
    <url>%2F2018%2F11%2F20%2FGrails3%E5%9C%A8utils%E4%B8%AD%E6%B3%A8%E5%85%A5bean%2F</url>
    <content type="text"><![CDATA[Grails3在utils中注入bean 在grails-app/conf/application.yml中配置用户基本信息 1234user: pserson-name: 张三 age: 20 sex: 男 在grails-app/utils下面新建一个JavaBean类 注意 这里的包名最好跟init/Application.groovy下面的保持一致，比如：Application.groovy是在com.demo下面，那么这个JavaBean也必须是在com.demo下面，例：com.demo.config 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.demo.config;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;@Configuration@ConfigurationProperties(prefix = "user")public class UserConfig &#123; private String psersonName; private Integer age; private char sex; public String getPsersonName() &#123; return psersonName; &#125; public void setPsersonName(String psersonName) &#123; this.psersonName = psersonName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return "UserConfig&#123;" + "psersonName='" + psersonName + '\'' + ", age='" + age + '\'' + ", sex=" + sex + '&#125;'; &#125;&#125; 新建UserUtils 1234567891011121314151617package com.demo.config;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class UserUtils &#123; @Autowired private UserConfig config; public String get() &#123; System.out.println(config); return "用户姓名为："+config.getPsersonName(); &#125;&#125; 别忘了在主配置类Application上面加上@ComponetScan启用组件扫描 123456@ComponentScanclass Application extends GrailsAutoConfiguration &#123; static void main(String[] args) &#123; GrailsApp.run(Application, args) &#125;&#125; 通过@Integration启用集成测试 12345678910111213141516171819202122232425262728293031323334package com.systemimport grails.test.mixin.TestForimport grails.test.mixin.integration.Integrationimport org.springframework.beans.factory.annotation.Autowiredimport org.springframework.boot.test.IntegrationTestimport spock.lang.Specificationimport websocket.UserUtils/** * See the API for &#123;@link grails.test.mixin.web.ControllerUnitTestMixin&#125; for usage instructions */@Integrationclass TestControllerSpec extends Specification &#123; @Autowired private UserUtils util def setup() &#123; &#125; def cleanup() &#123; &#125; void "user test" () &#123; expect: 'execlute' util.get() &#125; void "test something"() &#123; expect:"fix me" true == false &#125;&#125; 控制台打印12Grails application running at http://localhost:8080 in environment: developmentUserConfig&#123;psersonName='张三', age='20', sex=男&#125;]]></content>
      <categories>
        <category>Grails</category>
      </categories>
      <tags>
        <tag>Grails</tag>
        <tag>Groovy</tag>
        <tag>JavaBean</tag>
        <tag>Injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows常用dos命令]]></title>
    <url>%2F2018%2F11%2F14%2FWindows%E5%B8%B8%E7%94%A8dos%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[echo %变量名%查看某个系统变量的值 1echo %JAVA_HOME% cd命令进入指定盘符（绝对路径） -d 指定路径 123456789101112131415161718192021222324252627282930313233cd /d d:/test/hello显示当前目录名或改变当前目录。CHDIR [/D] [drive:][path]CHDIR [..]CD [/D] [drive:][path]CD [..] .. 指定要改成父目录。键入 CD drive: 显示指定驱动器中的当前目录。不带参数只键入 CD，则显示当前驱动器和目录。使用 /D 开关，除了改变驱动器的当前目录之外，还可改变当前驱动器。如果命令扩展被启用，CHDIR 会如下改变:当前的目录字符串会被转换成使用磁盘名上的大小写。所以，如果磁盘上的大小写如此，CD C:\TEMP 会将当前目录设为C:\Temp。CHDIR 命令不把空格当作分隔符，因此有可能将目录名改为一个带有空格但不带有引号的子目录名。例如: cd \winnt\profiles\username\programs\start menu与下列相同: cd "\winnt\profiles\username\programs\start menu"在扩展停用的情况下，你必须键入以上命令。 dir 查看目录及文件列表 1234567891011121314151617181920212223242526272829303132333435363738394041dir显示目录中的文件和子目录列表。DIR [drive:][path][filename] [/A[[:]attributes]] [/B] [/C] [/D] [/L] [/N] [/O[[:]sortorder]] [/P] [/Q] [/R] [/S] [/T[[:]timefield]] [/W] [/X] [/4] [drive:][path][filename] 指定要列出的驱动器、目录和/或文件。 /A 显示具有指定属性的文件。 属性 D 目录 R 只读文件 H 隐藏文件 A 准备存档的文件 S 系统文件 I 无内容索引文件 L 解析点 - 表示“否”的前缀 /B 使用空格式(没有标题信息或摘要)。 /C 在文件大小中显示千位数分隔符。这是默认值。用 /-C 来 禁用分隔符显示。 /D 跟宽式相同，但文件是按栏分类列出的。 /L 用小写。 /N 新的长列表格式，其中文件名在最右边。 /O 用分类顺序列出文件。 排列顺序 N 按名称(字母顺序) S 按大小(从小到大) E 按扩展名(字母顺序) D 按日期/时间(从先到后) G 组目录优先 - 反转顺序的前缀 /P 在每个信息屏幕后暂停。 /Q 显示文件所有者。 /R 显示文件的备用数据流。 /S 显示指定目录和所有子目录中的文件。 /T 控制显示或用来分类的时间字符域。 时间段 C 创建时间 A 上次访问时间 W 上次写入的时间 /W 用宽列表格式。 /X 显示为非 8.3 文件名产生的短名称。格式是 /N 的格式， 短名称插在长名称前面。如果没有短名称，在其位置则 显示空白。 /4 用四位数字显示年可以在 DIRCMD 环境变量中预先设定开关。通过添加前缀 - (破折号)来替代预先设定的开关。例如，/-W。 cls 清理屏幕 tree查看目录树 1234TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。 start 打开一个新的dos窗口或者打开本地当前所在目录 12345# 进入d盘下的test目录 cd /d d:/test # 打开当前所在目录 start .]]></content>
      <categories>
        <category>Windows技巧</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>dos</tag>
        <tag>cmd</tag>
        <tag>命令行</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中的slf4j日志依赖关系]]></title>
    <url>%2F2018%2F11%2F09%2FSpringBoot%E4%B8%AD%E7%9A%84slf4j%E6%97%A5%E5%BF%97%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[SpringBoot底层使用的是slf4j+logback来进行日志记录 把其他common-logging、log4j、java.util.logging转换为slf4j 底层依赖关系 关系如何转化 底层通过偷梁换柱的方法，用jcl、jul、log4j中间转换包进行转化 如果要引入其他框架，必须将其中默认日志依赖剔除 SpringBoot从maven依赖中剔除springframework:spring-core中的common-logging 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.20.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; SpringBoot默认日志级别为INFO级别 日志优先级从小到大顺序为： trace&lt;debug&lt;info&lt;warn&lt;error 12345678910111213141516171819202122232425package com.example.demo;import org.junit.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; Logger log = LoggerFactory.getLogger(getClass()); @Test public void contextLoads() &#123; log.trace("trace日志"); log.debug("debug日志"); log.info("info日志"); log.warn("warn日志"); log.error("error日志"); &#125;&#125; 启动运行，控制台打印只打印了info及以上级别 1232018-11-09 00:13:36.899 INFO 8156 --- [main] com.example.demo.DemoApplicationTests : info日志2018-11-09 00:13:36.900 WARN 8156 --- [main] com.example.demo.DemoApplicationTests : warn日志2018-11-09 00:13:36.900 ERROR 8156 --- [main] com.example.demo.DemoApplicationTests : error日志 日志基础配置 12345678910111213141516# 指定日志输入级别logging.level.com.example.demo=trace # 指定日志输出位置和日志文件名logging.file=./log/log.txt# 指定日志输出路径,若file和path同时配置,则file生效# 此配置默认生成文件为spring.log#logging.path=./log# 控制台日志输出格式# -5表示从左显示5个字符宽度logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight(%-5level) %boldYellow(%thread) | %boldGreen(%logger) | %msg%n# 文件中输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; = [%thread] = %-5level = %logger&#123;50&#125; - %msg%n]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>slf4j</tag>
        <tag>logback</tag>
        <tag>日志</tag>
        <tag>log4j</tag>
        <tag>common-logging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows中Google浏览器主页被恶意串改]]></title>
    <url>%2F2018%2F11%2F09%2FWindows%E4%B8%ADGoogle%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%BB%E9%A1%B5%E8%A2%AB%E6%81%B6%E6%84%8F%E4%B8%B2%E6%94%B9%2F</url>
    <content type="text"><![CDATA[当我们打开浏览器的时候它自动打开了某某网站的首页，这个时候我们如果需要重新配置自己的主页，或者去掉它设置的主页，该怎么办呢？ 1、浏览器地址栏目输入chrome://version，查看命令行看看是否正常 很显然上图中的浏览器首页被篡改了，指向了后面的http地址 2、通过Google浏览器设置查看启动时是否指定了http开头的地址 你可以通过这个设置来修改，若无效，请接着往下看 3、打开Google浏览器目标位置，复制一份重命名，然后右键-发送到桌面快捷方式 4、双击打开测试看看，主页是不是进入到了你设置页面，若不是5、选中刚刚发送到桌面的快捷方式–单机右键–属性–目标–最后面先一个空格，然后加上命令行：1--flag-switches-begin --flag-switches-end 最后查看，已经修改过来了]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Google浏览器</tag>
        <tag>浏览器</tag>
        <tag>恶意篡改</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java如何实现延时访问]]></title>
    <url>%2F2018%2F11%2F08%2FJava%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E6%97%B6%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[调用某个方法后，我们需要程序过一段时间再去处理，就可以用多线程阻塞或Timer定时器来实现 方法一 多线程阻塞实现方式 MyTask12345678910111213141516171819202122232425262728package abc;import java.util.concurrent.*;public class MyTask implements Callable&lt;Integer&gt; &#123; private int num; private int price; public MyTask(int num, int price) &#123; this.num = num; this.price = price; &#125; public int add(int m, int n) &#123; System.out.println("执行运算..."+"\n"); return m * n; &#125; @Override public Integer call() throws Exception &#123; //睡眠5秒 Thread.sleep(5 * 1000L); return add(num,price); &#125;&#125; 测试类12345678910111213141516171819package abc;import org.junit.Test;import java.util.concurrent.FutureTask;public class ThreadTest &#123; @Test public void c() throws Exception &#123; MyTask task = new MyTask(10,20); FutureTask&lt;Integer&gt; resultObject = new FutureTask&lt;Integer&gt;(task); new Thread(resultObject).start(); //阻塞当前线程 int result = resultObject.get(); System.out.println(result); &#125;&#125; 方法二 通过Timer定时器实现 TestTimerTask1234567891011121314151617181920212223242526package abc;import java.util.Date;import java.util.TimerTask;public class TestTimerTask extends TimerTask &#123; private String username; private int age; public TestTimerTask(String username, int age) &#123; this.username = username; this.age = age; &#125; @Override public void run() &#123; // 处理业务逻辑 System.out.println("开始处理."); System.out.println("大家好，我叫" + username + "，今年" + age + "岁"); System.out.println("结束时间："+new Date().toLocaleString()); System.gc(); cancel(); &#125;&#125; 测试类12345678910111213141516package abc;import java.util.Date;import java.util.Timer;public class TimerTest &#123; public static void main(String[] args) &#123; System.out.println("开始时间："+new Date().toLocaleString()); Timer timer = new Timer(); System.out.println("一："+timer); timer.schedule(new TestTimerTask("张三",20),5000); System.out.println(timer); &#125;&#125; 输出结果12345678开始时间：2018-11-8 17:21:49一：java.util.Timer@6acbcfc0java.util.Timer@6acbcfc0开始处理.大家好，我叫张三，今年20岁结束时间：2018-11-8 17:21:54Process finished with exit code 0 注意 Timer测试不能用单元测试]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Callable</tag>
        <tag>Timer</tag>
        <tag>接口访问频率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置文件优先级加载顺序]]></title>
    <url>%2F2018%2F11%2F08%2FSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BC%98%E5%85%88%E7%BA%A7%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[配置文件优先级从高到低顺序↓ file:./config/ - 优先级最高（项目根路径下的config） file:./ - 优先级第二 -（项目根路径下） classpath:/config/ - 优先级第三（项目resources/config下） classpath:/ - 优先级第四（项目resources根目录） SpringBoot项目启动会去扫面项目以上目录位置的application.yml或application.properties文件 以上位置的application.yml或application.properties遵循： 高优先级配置会覆盖低优先级配置 多个配置文件互补 比如，两个同名文件里面有相同的配置，相同的配置会被高优先级的配置覆盖 A配置优先级大于B配置 12server: port: 8080 B配置优先级小于A配置 123server: port: 8081 context-path: /test 项目启动后访问地址为：http://localhost:8080/test，这就是所谓的互补 项目打包运行后可通过命令指定配置文件位置1--spring.config.location=d:/application.properties 实例 1java -jar demo-xxx.jar --spring.config.location=d:/application.properties 这对于运维来说非常方便，在不破坏原配置情况下轻松修改少量配置就可以达到想要的效果]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>配置</tag>
        <tag>优先级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置Profile多环境支持]]></title>
    <url>%2F2018%2F11%2F08%2FSpringBoot%E9%85%8D%E7%BD%AEProfile%E5%A4%9A%E7%8E%AF%E5%A2%83%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[Profile是Spring对不同环境提供不同配置功能的支持，可以通过不同需求激活指定环境配置1、多Profile文件定义形式 application-{profile}.properties或者application-{profile}.yml application-dev.properties 或application-dev.yml application-test.properties 或application-test.yml application-prod.properties 或application-prod.yml 2、多profile文档块形式1234567891011121314151617---server: port: 8080spring: profiles: prod---server: port: 8081spring: profiles: test ---server: port: 8082spring: profiles: dev 激活方式1、在yml或者properties中通过配置激活123spring: profiles: active: dev # 激活开发环境 2、命令行激活1--spring.profiles.active=dev 此命令式在IDEA中Program arguments输入框中设置 部署到本地激活方式 1java -jar demo-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod 3、JVM虚拟机参数激活 在IDEA中VM Options中输入框中设置 1-Dspring.profiles.active=dev 部署到本地激活方式 1java -jar -Dspring.profiles.active=test demo-0.0.1-SNAPSHOT.jar]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Profile</tag>
        <tag>多环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置文件占位符]]></title>
    <url>%2F2018%2F11%2F07%2FSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8D%A0%E4%BD%8D%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[在properties或yaml配置文件中是可以使用占位符的 1、随机数 ${random.value} - 类似uuid的随机数，没有”-“连接 ${random.int} - 随机取整型范围内的一个值 ${random.long} - 随机取长整型范围内的一个值 ${random.long(100,200)} - 随机生成长整型100-200范围内的一个值 ${random.uuid} - 生成一个uuid，有短杠连接 ${random.int(10)} - 随机生成一个10以内的数 ${random.int(100,200)} - 随机生成一个100-200 范围以内的数 例子 1234567#user.username=$&#123;random.value&#125;#user.username=$&#123;random.int&#125;#user.username=$&#123;random.long&#125;#user.username=$&#123;random.uuid&#125;#user.username=$&#123;random.int(10)&#125;#user.username=$&#123;random.int(100,200)&#125;user.username=$&#123;random.long(100,200)&#125; 2、占位符 ${key:defaultValue} - 若key 不存在，则将defaultValue的值赋值给取值的对象 例子 ${user.username} 当在配置文件中用这个表达式，而user.username未定义的时候，取值时会将${user.username} 当做字符串处理 1user.username=$&#123;test.xx:周伯通&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>占位符</tag>
        <tag>默认值</tag>
        <tag>SpEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot单元测试]]></title>
    <url>%2F2018%2F11%2F07%2FSpringBoot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在测试类中读取某个application-开头的properties或yaml中的属性命名规则 必须以application-开头 application-dev.properties application-test.properties application-dev.yml application-dev.yml 通过@ActiveProfiles来指定使用哪个文件 例子12345678910111213141516171819202122232425262728package com.atgenee.demo;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest@ActiveProfiles("test") //指定使用application-test.ymlpublic class TestApplicationTests &#123; @Value("$&#123;user.first-name&#125;") private String firstName; @Value("$&#123;user.weight&#125;") private Integer weight; @Test public void hei() &#123; System.out.println(firstName); System.out.println(weight); &#125;&#125; @TestPropertySource 加载指定配置文件 可以是properties文件，也可以是yaml 例子123456789101112131415161718192021222324252627package com.atgenee.demo;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.TestPropertySource;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTest@TestPropertySource(properties = &#123; "spring.config.location = classpath:test.properties" &#125;)public class TestApplicationTests &#123; @Value("$&#123;user.first-name&#125;") private String firstName; @Value("$&#123;user.weight&#125;") private Integer weight; @Test public void hei() &#123; System.out.println(firstName); System.out.println(weight); &#125;&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>yaml</tag>
        <tag>yml</tag>
        <tag>自定义yml</tag>
        <tag>自定义yaml</tag>
        <tag>自定义properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中@PropertySource和@ImportResource以及@Bean]]></title>
    <url>%2F2018%2F11%2F07%2FSpringBoot%E4%B8%AD%40PropertySource%E5%92%8C%40ImportResource%E4%BB%A5%E5%8F%8A%40Bean%2F</url>
    <content type="text"><![CDATA[@PropertySource 加载指定的配置文件 只能加载*.properties文件，不能加载yaml文件 新建一个user.properties 123456user.nickname=张三user.age=19user.sex=男user.maps.weight=70user.maps.height=170user.address.addr=重庆市渝中区 UserBean 123456789101112131415@Component@PropertySource(value = &#123;"classpath:user.properties"&#125;)@ConfigurationProperties(prefix = "user")public class User &#123; private String nickname; private Integer age; private char sex; private Map&lt;String,Integer&gt; maps; private Address address; ...&#125; @ImportResource 导入Spring的配置文件，让配置文件里面的内容生效 SpringBoot中编写的Spring配置文件是不能自动识别的 在主配置类上加入@ImportResource 1@ImportResource(locations = &#123;"classpath:beans.xml"&#125;) SpringBoot给容器添加组件的方式1、配置类 == Spring配置文件 通过@Configuration声明2、使用@Bean给容器添加组件，组件id默认为方法名例子1234567891011121314package com.atgenee.demo.service;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class Hello &#123; @Bean public Hello helloService() &#123; System.out.println("添加组件"); return new Hello(); &#125;&#125; 测试1234567891011121314151617181920212223242526272829package com.atgenee.demo;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.ApplicationContext;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class HelloServiceApplicationTests &#123; // @Autowired// private Hello hello;//// @Test// public void hello() &#123;// hello.helloService();// &#125; @Autowired private ApplicationContext ioc; @Test public void hello() &#123; ioc.getBean("helloService"); &#125;&#125; 请注意 若配置类已经加了@Bean注解，此时配置类中的方法名不能跟类名一样，也就是上面的Hello类中不能定义hello()的方法，否则报错 通过自定义工厂来实现自定义yaml文件加载新建一个cat.yml文件1234cat: age: 3 height: 20 weight: 5 工厂类12345678910111213141516171819202122232425262728293031323334353637package com.atgenee.demo.factory;import java.io.FileNotFoundException;import java.io.IOException;import java.util.Properties;import org.springframework.beans.factory.config.YamlPropertiesFactoryBean;import org.springframework.core.env.PropertiesPropertySource;import org.springframework.core.env.PropertySource;import org.springframework.core.io.support.EncodedResource;import org.springframework.core.io.support.PropertySourceFactory;import org.springframework.lang.Nullable;public class YamlPropertySourceFactory implements PropertySourceFactory &#123; @Override public PropertySource&lt;?&gt; createPropertySource(@Nullable String name, EncodedResource resource) throws IOException &#123; Properties propertiesFromYaml = loadYamlIntoProperties(resource); String sourceName = name != null ? name : resource.getResource().getFilename(); return new PropertiesPropertySource(sourceName, propertiesFromYaml); &#125; private Properties loadYamlIntoProperties(EncodedResource resource) throws FileNotFoundException &#123; try &#123; YamlPropertiesFactoryBean factory = new YamlPropertiesFactoryBean(); factory.setResources(resource.getResource()); factory.afterPropertiesSet(); return factory.getObject(); &#125; catch (IllegalStateException e) &#123; // for ignoreResourceNotFound Throwable cause = e.getCause(); if (cause instanceof FileNotFoundException) throw (FileNotFoundException) e.getCause(); throw e; &#125; &#125;&#125; 新建配置类 Cat，配合@PropertySource 注解使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.atgenee.demo.config;import com.atgenee.demo.factory.YamlPropertySourceFactory;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(factory = YamlPropertySourceFactory.class, value = "classpath:cat.yml")@ConfigurationProperties(prefix = "cat")public class Cat &#123; private int age; private Double weight; private Double height; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Double getWeight() &#123; return weight; &#125; public void setWeight(Double weight) &#123; this.weight = weight; &#125; public Double getHeight() &#123; return height; &#125; public void setHeight(Double height) &#123; this.height = height; &#125; @Override public String toString() &#123; return "Cat&#123;" + "age=" + age + ", weight=" + weight + ", height=" + height + '&#125;'; &#125;&#125; Cat测试类12345678910111213141516171819202122package com.atgenee.demo;import com.atgenee.demo.config.Cat;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class CatApplicationTests &#123; @Autowired private Cat cat; @Test public void hei() &#123; System.out.println(cat); &#125;&#125; 控制台输出1Cat&#123;age=3, weight=5.0, height=20.0&#125;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>yaml</tag>
        <tag>yml</tag>
        <tag>自定义yml</tag>
        <tag>自定义yaml</tag>
        <tag>自定义properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yaml基本语法]]></title>
    <url>%2F2018%2F11%2F06%2Fyaml%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[YAML用法 对象或键值对 1、普通用法123user: name: zhangsan age: 20 2、行内用法1user: &#123;name: zhangsan,age: 20&#125; 数组 1、普通用法1234pets: - pig - dog - cat 2、行内写法1ptes: [pig,dog,cat]]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>yaml</tag>
        <tag>yml</tag>
        <tag>application.yml</tag>
        <tag>application.properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows以管理员运行快捷方式]]></title>
    <url>%2F2018%2F11%2F06%2Fwindows%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BF%90%E8%A1%8C%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Windows通过右键菜单，快捷打开CMD(Admin)窗口 创建一个后缀为.reg的文件，将下面的内容复制复制到该文件中 12345678910111213141516171819202122Windows Registry Editor Version 5.00; Created by: Shawn Brink; http://www.sevenforums.com; Tutorial: http://www.sevenforums.com/tutorials/47415-open-command-window-here-administrator.html[-HKEY_CLASSES_ROOT\Directory\shell\runas][HKEY_CLASSES_ROOT\Directory\shell\runas]@=&quot;Open CMD&quot;&quot;HasLUAShield&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Directory\shell\runas\command]@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;[-HKEY_CLASSES_ROOT\Directory\Background\shell\runas][HKEY_CLASSES_ROOT\Directory\Background\shell\runas]@=&quot;Open CMD&quot;&quot;HasLUAShield&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Directory\Background\shell\runas\command]@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;[-HKEY_CLASSES_ROOT\Drive\shell\runas][HKEY_CLASSES_ROOT\Drive\shell\runas]@=&quot;Open CMD&quot;&quot;HasLUAShield&quot;=&quot;&quot;[HKEY_CLASSES_ROOT\Drive\shell\runas\command]@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot; 最后双击添加到注册表中]]></content>
      <categories>
        <category>Windows技巧</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot读取yaml配置]]></title>
    <url>%2F2018%2F11%2F06%2FSpringBoot%E8%AF%BB%E5%8F%96yaml%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot读取yaml配置的值 在application.yml中添加配置 1234567891011121314user: name: 张三 age: 19 sex: 男 maps: &#123;weight: 70,height: 170&#125; address: addr: 重庆市渝中区 lists: - 京东 - 淘宝 - 坑多多 新建Address类 123456789101112131415161718192021package com.atgenee.demo.config;public class Address &#123; private String addr; public String getAddr() &#123; return addr; &#125; public void setAddr(String addr) &#123; this.addr = addr; &#125; @Override public String toString() &#123; return "Address&#123;" + "addr='" + addr + '\'' + '&#125;'; &#125;&#125; 新建User类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.atgenee.demo.config;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;@Component@ConfigurationProperties(prefix = "user")public class User &#123; private String name; private Integer age; private char sex; private Map&lt;String,Integer&gt; maps; private Address address; private List&lt;String&gt; lists; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; public Map&lt;String, Integer&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Integer&gt; maps) &#123; this.maps = maps; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public List&lt;String&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;String&gt; lists) &#123; this.lists = lists; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + ", sex=" + sex + ", maps=" + maps + ", address=" + address + ", lists=" + lists + '&#125;'; &#125;&#125; 新建测试类1234567891011121314151617181920212223package com.atgenee.demo;import com.atgenee.demo.config.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class UserApplicationTests &#123; //注入配置类 @Autowired User user; @Test public void contextLoads() &#123; System.out.println(user); &#125;&#125; 测试结果1User&#123;name='Administrator', age=19, sex=男, maps=&#123;weight=70, height=170&#125;, address=Address&#123;addr='重庆市渝中区'&#125;, lists=[京东, 淘宝, 坑多多]&#125; 注意 yaml格式要求严格，以键值形式配置，键后冒号后面的空格一定不要丢（如: username: admin） @ConfigurationProperties注解依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>yaml</tag>
        <tag>yml</tag>
        <tag>application.yml</tag>
        <tag>application.properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置proxy_pass后，访问时路径丢失怎么办]]></title>
    <url>%2F2018%2F11%2F01%2Fnginx%E9%85%8D%E7%BD%AEproxy_pass%E5%90%8E%EF%BC%8C%E8%AE%BF%E9%97%AE%E6%97%B6%E8%B7%AF%E5%BE%84%E4%B8%A2%E5%A4%B1%E6%80%8E%E4%B9%88%E5%8A%9E%2F</url>
    <content type="text"><![CDATA[应用场景 当我访问blog.first-blood.cn的时候，proxy_pass转发到jonny023.github.io这个域名下去了，而jonny023.github.io/upload/hello.jpg这个文件我通过blog.first-blood.cn/upload/hello.jpg访问就出现404 解决办法 此时在nginx的配置文件下的location配置下面添加一句 1proxy_set_header Host jonny023.github.io; 注意知道对不对，如果不对请来砍我1234567891011121314151617181920212223242526272829303132333435363738server &#123; listen 80; server_name blog.first-blood.cn; charset utf-8,gbk; root html; index index.html index.htm; location / &#123; proxy_set_header Host jonny023.github.io; #proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass https://jonny023.github.io; &#125; location ^~/archives/ &#123; proxy_pass https://jonny023.github.io/archives/; &#125; location ^~/uploads/ &#123; proxy_pass https://jonny023.github.io/uploads/; &#125; location /favico.ico &#123; proxy_pass https://jonny023.github.io; charset utf-8,gbk; expires 12h; &#125; location ~ .*\.(js|css|eot|otf|ttf|woff|woff2)?$ &#123; proxy_pass https://jonny023.github.io; charset utf-8,gbk; expires 12h; &#125; location ~* \.(eot|otf|ttf|woff|woff2)$ &#123; add_header Access-Control-Allow-Origin *; &#125;&#125;]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringUtils工具包join方法转字符]]></title>
    <url>%2F2018%2F11%2F01%2FStringUtils%E5%B7%A5%E5%85%B7%E5%8C%85join%E6%96%B9%E6%B3%95%E8%BD%AC%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[作用 将集合、数组元素通过指定字符连接为一个字符串 StringUtils.join()跟JDK1.8里面的String.join()差不多 依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 具体代码123456789101112131415161718public static void main(String[] args) &#123; List list = new ArrayList(); list.add("市场"); list.add("销售"); list.add("运维"); // 集合 String str = StringUtils.join(list,","); System.out.println(str); // 数组 Object[] arrs = &#123;10010,10011,10086,10000&#125;; String s = StringUtils.join(arrs,","); System.out.println(s);&#125; 执行结果 注意 StringUtils转数组的时候，只能是Object类型的数组]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle case when then分组排序]]></title>
    <url>%2F2018%2F11%2F01%2FOracle%20case%20when%20then%E5%88%86%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[问题描述 Oracle数据库使用case when then end别名后，group by不能使用这个别名，但是order by可以 使用函数 TO_CHAR( SYSDATE, &#39;yyyy&#39; )作用是获取系统时间年份 EXTRACT( year FROM DATE_CREATED )作用是获取表字段年份 示例代码1234567891011121314151617181920SELECT COUNT( * ) AS rs,CASE WHEN TO_CHAR( SYSDATE, &apos;yyyy&apos; ) - TO_CHAR( NAT_DATE, &apos;yyyy&apos; ) &lt; 18 THEN &apos;17岁及其以下&apos; END nFROM PERSON_INFO WHERE EXTRACT( year FROM DATE_CREATED ) = &apos;2018&apos; AND person_status = 0GROUP BY CASE WHEN TO_CHAR( SYSDATE, &apos;yyyy&apos; ) - TO_CHAR( NAT_DATE, &apos;yyyy&apos; ) &lt; 18 THEN &apos;17岁及其以下&apos; ENDORDER BY n 目前解决方案是分组时直接使用case when then end完整代码，若有大佬有其他解决方案，请联系我，Thanks!]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx本地域名映射及tomcat集群session共享]]></title>
    <url>%2F2018%2F10%2F26%2Fnginx%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D%E6%98%A0%E5%B0%84%E5%8F%8Atomcat%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[本地域名映射 修改C:\Windows\System32\drivers\etc下的hosts文件，在hosts中添加 1127.0.0.1 www.cms.com nginx配置集群配置 修改nginx.conf文件 1234567891011121314151617181920http &#123; upstream local &#123; server 127.0.0.1:8889; server 127.0.0.1:8880; ip_hash; # 解决session共享问题 &#125; server &#123; listen 80; server_name localhost; location / &#123; charset utf-8,gbk; # 解决中文乱码问题。 proxy_pass http://local; &#125; &#125; &#125;]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Tomcat</tag>
        <tag>Tomcat集群</tag>
      </tags>
  </entry>
</search>
